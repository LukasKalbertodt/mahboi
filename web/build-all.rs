#!/usr/bin/env run-cargo-script

// cargo-deps: failure, term-painter
//
// This file should instead be called `build.rs`, but this is currently not
// possible. See: https://github.com/DanielKeep/cargo-script/issues/58

#[macro_use]
extern crate failure;
extern crate term_painter;

use failure::{Error, ResultExt};
use term_painter::{Attr, Color, ToStyle};

use std::{
    fs::{self, File},
    io::{BufRead, BufReader},
    path::Path,
    process::Command,
};



fn main() {
    if let Err(e) = run() {
        println!(
            "  [!!!] üí• {}",
            Color::Red.bold().paint(&e),
        );

        for cause in e.iter_causes() {
            println!("       ... caused by: {}", cause);
        }
    }
}

/// Wrapper for the actual `main` to catch errors.
fn run() -> Result<(), Error> {
    let release_mode = match &std::env::args().nth(1) {
        Some(s) if s == "--release" => true,
        _ => false,
    };

    // Create out dir if it doesn't exist yet.
    let out_dir = Path::new("dist");
    if !out_dir.exists() {
        fs::create_dir(out_dir)?;
    }

    cargo_build(release_mode)?;
    wasm_bindgen(release_mode, out_dir)?;
    compile_typescript(out_dir)?;
    copy_into_dist(out_dir)?;
    println!();

    Ok(())
}

/// Run `cargo build --target wasm32-unknown-unknown`.
fn cargo_build(release_mode: bool) -> Result<(), Error> {
    println!(
        "  [1/4] üåÄ {} (`cargo build{}`) ...",
        Attr::Bold.paint("Compiling Rust to WASM"),
        if release_mode { " --release" } else { "" },
    );

    let mut args = vec!["build", "--target", "wasm32-unknown-unknown"];
    if release_mode {
        args.push("--release");
    }

    let status = Command::new("cargo")
        .args(args)
        .spawn()
        .context("failed to spawn `cargo`")?
        .wait()?;

    if !status.success() {
        bail!("Failed to run `cargo` (exit code {:?})", status.code());
    }

    Ok(())
}

/// Run `wasm-bindgen --no-modules ...`
fn wasm_bindgen(release_mode: bool, out_dir: &Path) -> Result<(), Error> {
    println!(
        "  [2/4] üîó {} ... ",
        Attr::Bold.paint("Running `wasm-bindgen`"),
    );

    // Determine path of the WASM file generated by cargo
    let folder = match release_mode {
        true => "release",
        false => "debug",
    };
    let input = format!("../target/wasm32-unknown-unknown/{}/mahboi_web.wasm", folder);

    // Execute `wasm-bindgen` and let it put all the files in `dist`. Three
    // files are written:
    // - `mahboi_web.js` (JS shim)
    // - `mahboi_web_bg.wasm`
    // - `mahboi_web.d.ts` (TS declarations)
    let status = Command::new("wasm-bindgen")
        .arg("--no-modules")
        .arg("--out-dir")
        .arg(out_dir)
        .arg(input)
        .spawn()
        .context("failed to spawn `wasm-bindgen`")?
        .wait()?;

    if !status.success() {
        bail!("Failed to run `wasm-bindgen` (exit code {:?})", status.code());
    }

    // We need to postprocess the typescript definition file emitted by
    // wasm-bg. We wrap the whole file into `namespace mahboi_web { ... }` and
    // add a `mahboi_web` function at the end.
    let type_decl_path = out_dir.join("mahboi_web.d.ts");
    let orig = BufReader::new(File::open(&type_decl_path)?);

    let mut types = String::new();
    types.push_str("declare namespace wasm_bindgen {\n");
    for line in orig.lines() {
        types.push_str("    ");
        types.push_str(&line?);
        types.push_str("\n");
    }
    types.push_str("}\n");
    types.push_str("\n");
    types.push_str("declare function wasm_bindgen(path: string): Promise<void>;\n");

    // Write the modified version to `src/` and remove the original file.
    fs::write(Path::new("src").join("mahboi.d.ts"), &types)?;
    fs::remove_file(&type_decl_path)?;

    Ok(())
}

/// Just execute `tsc`.
fn compile_typescript(out_dir: &Path) -> Result<(), Error> {
    println!(
        "  [3/4] üî¨ {} ...",
        Attr::Bold.paint("Compiling TypeScript"),
    );

    let src_file = Path::new("src").join("main.ts").metadata()?;
    let decl_file = Path::new("src").join("mahboi.d.ts").metadata()?;
    let out_file = out_dir.join("main.js").metadata()?;

    // The TS compiler can be super slow, so we check if compilation is
    // necessary.
    let is_up_to_date = src_file.modified()? < out_file.modified()?
        && decl_file.modified()? < out_file.modified()?;
    if is_up_to_date {
        println!("           ... files up to date.");
        return Ok(());
    }

    let status = Command::new("tsc")
        .spawn()
        .context("failed to spawn `tsc`")?
        .wait()?;

    if !status.success() {
        bail!("Failed to run `tsc` (exit code {:?})", status.code());
    }

    Ok(())
}

/// Copies all files from `static/` to `dist/`.
fn copy_into_dist(out_dir: &Path) -> Result<(), Error> {
    println!(
        "  [4/4] üéÅ {} ...",
        Attr::Bold.paint("Copy static files into `dist/`"),
    );

    for entry in fs::read_dir("static")? {
        let entry = entry?;
        if entry.file_type()?.is_file() {
            let dst = out_dir.join(entry.file_name());
            fs::copy(entry.path(), dst)?;
        }
    }

    Ok(())
}
